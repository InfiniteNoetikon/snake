<!doctype html>
<html lang="en">
	<head>
		<meta name=”viewport” content=”width=device-width, initial-scale=1″>
		<title>Snake Game</title>
		<link rel="icon" type="image/png" href="https://lh6.googleusercontent.com/dY0PlvfHkL-D2M4p7yqePDu4xIvVqdMXerLmDE_IGCR0mc0OO360vZwfi01GCeI9BnbY9zw=w371"></link>
		<!-- Basic styling, centering of the canvas. -->
		<style>
			body {
				background: lightgrey;
			}
			
			#wrapper
			{
				background: red;
				width: 100%;
				margin-right: auto;
				margin-left: auto;
			}
			
			html, body, {
				position:fixed;
				top:0;
				bottom:0;
				left:0;
				right:0;
			}
			
			h1.title{
				position: absolute;
				margin-left: auto;
				margin-right: auto;
				left: 0;
				right: 0;
				top: 5%;
				color: red;
				font-size: 500%;
			}
			
			canvas {
				display: block;
				position: absolute;
				top: 28%;
				margin-left: auto;
				margin-right: auto;
				background: black;
				left: 0;
				right: 0;
				top = 5%
				background: black;
				border: 1px solid #000;
				z-index: -1;
			}
			
			input.settings {
				align: center;
				width: height;
				height: 5%;
				opacity: 1;
				opacity: 0.4;
				z-index: 1;
				position: absolute;
				margin-left: auto;
				margin-right: auto;
				top: 29%;
				left: 63%
			}
			
			input.settings2:hover{
				opacity: 1;
			}
			
			img.pause{
				position: absolute;
				margin-left: auto;
				margin-right: auto;
				top: 35%;
				right: 0;
				left: 0;
				height: 500px;
				width: 500px;
				opacity: 1.0;
			}
			
			div.controls {
				border: solid black;
				background: white;
				width: 13%;
				height: 25%;
				position: fixed;
				left: 20%;
				top: 45%;
				padding: 0.5;
			}
			
			p.controls{
				text-indent: 1em;
			}
			
		</style>
	</head>
	<body>
		<br> <br>
			<h1 align="center" class="title"> Let's Play Snake! </h1>
			<input type="image" onclick="changeSetting()" src="settings.png" class="settings settings2" id="set" title="Walls set to off"> 
			<br>
			<div id="d1" class="controls"> <h1> Controls </h1> <p class="controls"> • [spacebar]: pause </p></div>
			<img src="pause.png" class="pause" id="pause"/>
		<script>
			var
			//constats
			COLS = 30, ROWS = 30, SNAKE = 1, FRUIT = 2, EMPTY = 3,
			LEFT  = 0, UP = 1, RIGHT = 2, DOWN  = 3,
			SPACE = 32, KEY_LEFT  = 37, KEY_UP    = 38, KEY_RIGHT = 39, KEY_DOWN  = 40,
			
			//game objects
			canvas, ctx, keystate, frames, score,
			
			//other objects
			pause = 0, setting = 1, image = document.getElementById("pause");

			grid = {
				width: null,  /* number, the number of columns */
				height: null, /* number, the number of rows */
				_grid: null,  /* Array<any>, data representation */
				
				init: function(d, c, r) {
					this.width = c;
					this.height = r;
					this._grid = [];
					for (var x=0; x < c; x++) {
						this._grid.push([]);
						for (var y=0; y < r; y++) {
							this._grid[x].push(d);
						}
					}
				},

				set: function(val, x, y) {
					this._grid[x][y] = val;
				},

				get: function(x, y) {
					return this._grid[x][y];
				}
			}

			snake = {
				direction: null, /* number, the direction */
				last: null,		 /* Object, pointer to the last element in
									the queue */
				_queue: null,	 /* Array<number>, data representation*/

				init: function(d, x, y) {
					this.direction = d;
					this._queue = [];
					this.insert(x, y);
					this.insert(x, y-1);
					this.insert(x,y-2);
				},
				
				insert: function(x, y) {
					// unshift prepends an element to an array
					this._queue.unshift({x:x, y:y});
					this.last = this._queue[0];
				},
				/**
				 * Removes and returns the first element in the queue.
				 * 
				 * @return {Object} the first element
				 */
				remove: function() {
					// pop returns the last element of an array
					return this._queue.pop();
				}
			};
			
			function setFood() {
				var empty = [];
				// iterate through the grid and find all empty cells
				for (var x=0; x < grid.width; x++) {
					for (var y=0; y < grid.height; y++) {
						if (grid.get(x, y) === EMPTY) {
							empty.push({x:x, y:y});
						}
					}
				}
				// chooses a random cell
				var randpos = empty[Math.round(Math.random()*(empty.length - 1))];
				grid.set(FRUIT, randpos.x, randpos.y);

			}
			function play() {
				// create and initiate the canvas element
				canvas = document.createElement("canvas");
				canvas.width = COLS*20;
				canvas.height = ROWS*20;
				ctx = canvas.getContext("2d");
				
				// add the canvas element to the body of the document
				document.body.appendChild(canvas);
				
				// sets an base font for bigger score display
				ctx.font = "20px Helvetica";
				frames = 0;
				keystate = {};
				
				// keeps track of the keybourd input
				document.addEventListener("keydown", function(evt) {keystate[evt.keyCode] = true;});
				document.addEventListener("keyup", function(evt) {delete keystate[evt.keyCode];});
				
				// intatiate game objects and starts the game loop
				init();
				loop();
			}

			function init() {
				score = 0;
				grid.init(EMPTY, COLS, ROWS);
				var sp = {x:Math.floor(COLS/2), y:ROWS-1};
				snake.init(UP, sp.x, sp.y);
				grid.set(SNAKE, sp.x, sp.y);
				setFood();
			}
			
			function loop() {
				if (keystate[SPACE]){
					pause++;
				}
				if (pause % 2 == 0){
					image.style.opacity = 0;
					switch (setting){
						case 1:
							updateWallsOff();
							draw();
							break;
						case 2:
							updateWallsOn()
							draw();
							break;
					}
				}
				else{
					image.style.opacity = 1;
				}
				
				window.requestAnimationFrame(loop, canvas);
			}
			
			function updateWallsOn() {
				frames++;
				// changing direction of the snake depending on which keys
				// that are pressed
				if (keystate[KEY_LEFT] && !keystate[KEY_UP] && !keystate[KEY_RIGHT] && !keystate[KEY_DOWN] && snake.direction !== RIGHT ) {
					snake.direction = LEFT;
				}
				if (keystate[KEY_UP] && !keystate[KEY_DOWN] && !keystate[KEY_LEFT] && !keystate[KEY_RIGHT] && snake.direction !== DOWN) {
					snake.direction = UP;
				}
				if (keystate[KEY_RIGHT] && !keystate[KEY_UP] && !keystate[KEY_DOWN] && !keystate[KEY_LEFT] && snake.direction !== LEFT) {
					snake.direction = RIGHT;
				}
				if (keystate[KEY_DOWN] && !keystate[KEY_LEFT] && !keystate[KEY_UP] && !keystate[KEY_RIGHT] && snake.direction !== UP) {
					snake.direction = DOWN;
				}
				// each five frames update the game state.
				if (frames%5 === 0) {
					// pop the last element from the snake queue i.e. the
					// head
					var nx = snake.last.x;
					var ny = snake.last.y;
					// updates the position depending on the snake direction
					switch (snake.direction) {
						case LEFT:
							nx--;
							break;
						case UP:
							ny--;
							break;
						case RIGHT:
							nx++;
							break;
						case DOWN:
							ny++;
							break;
					}
					// checks all gameover conditions
					if (0 > nx || nx > grid.width-1  ||
						0 > ny || ny > grid.height-1 ||
						grid.get(nx, ny) === SNAKE
					) {
						return init();
					}
					// check wheter the new position are on the fruit item
					if (grid.get(nx, ny) === FRUIT) {
						// increment the score and sets a new fruit position
						score++;
						setFood();
					} else {
						// take out the first item from the snake queue i.e
						// the tail and remove id from grid
						var tail = snake.remove();
						grid.set(EMPTY, tail.x, tail.y);
					}
					// add a snake id at the new position and append it to 
					// the snake queue
					grid.set(SNAKE, nx, ny);
					snake.insert(nx, ny);
				}
			}

			function updateWallsOff() {
				frames++;
				
				// changing direction of the snake depending on which keys
				// that are pressed
				if (keystate[KEY_LEFT] && snake.direction !== RIGHT && !keystate[KEY_UP] && !keystate[KEY_DOWN] && !keystate[KEY_RIGHT]) {
					snake.direction = LEFT;
				}
				if (keystate[KEY_UP] && snake.direction !== DOWN && !keystate[KEY_LEFT] && !keystate[KEY_DOWN] && !keystate[KEY_RIGHT]) {
					snake.direction = UP;
				}
				if (keystate[KEY_RIGHT] && snake.direction !== LEFT && !keystate[KEY_UP] && !keystate[KEY_DOWN] && !keystate[KEY_LEFT]) {
					snake.direction = RIGHT;
				}
				if (keystate[KEY_DOWN] && snake.direction !== UP && !keystate[KEY_UP] && !keystate[KEY_LEFT] && !keystate[KEY_RIGHT]) {
					snake.direction = DOWN;
				}
				
				// each five frames update the game state.
				if (frames%5 === 0) {
					// pop the last element from the snake queue i.e. the
					// head
					var nx = snake.last.x;
					var ny = snake.last.y;
					// updates the position depending on the snake direction
					switch (snake.direction) {
						case LEFT:
							nx--;
							break;
						case UP:
							ny--;
							break;
						case RIGHT:
							nx++;
							break;
						case DOWN:
							ny++;
							break;
					}
					
					//removes walls
					if (nx < 0) {
						nx = grid.width-1;
					}
					else if (nx >= grid.width) {
						nx = 0;
					}
					
					if (ny < 0) {
						ny = grid.height-1;
					}
					else if (ny >= grid.height) {
						ny = 0;
					}
				
					// checks gameover condition
					if (grid.get(nx, ny) == SNAKE) {
						return init();
					}
					
					// check wheter the new position are on the fruit item
					if (grid.get(nx, ny) === FRUIT) {
						// increment the score and sets a new fruit position
						score++;
						setFood();
					} 
					else {
						// take out the first item from the snake queue i.e
						// the tail and remove id from grid
						var tail = snake.remove();
						grid.set(EMPTY, tail.x, tail.y);
					}

					grid.set(SNAKE, nx, ny);
					snake.insert(nx, ny);
				}
				
			}

			function draw() {
				var tw = canvas.width/grid.width;
				var th = canvas.height/grid.height;

				for (var x=0; x < grid.width; x++) {
					for (var y=0; y < grid.height; y++) {

						switch (grid.get(x, y)) {
							case EMPTY:
								ctx.fillStyle = "black";
								ctx.fillRect(x*tw, y*th, tw, th);
								break;
							case SNAKE:
								ctx.fillStyle = "green";
								ctx.fillRect(x*tw, y*th, tw-1, th-1);
								break;
							case FRUIT:
								ctx.fillStyle = "#f00";
								ctx.fillRect(x*tw, y*th, tw-1, th-1);
								break;
						}
					}
				}

				ctx.fillStyle = "White";
				
				ctx.fillText("SCORE: " + score, 10, canvas.height-10);
			}
			
			function changeSetting(){
				if (setting == 1){
					init();
					document.getElementById("set").src = "settings2.png";
					document.getElementById("set").title = "Walls set to on";
					setting = 2;
				}
				else{
					init();
					document.getElementById("set").src = "settings.png";
					document.getElementById("set").title = "Walls set to off";
					setting = 1;
				}
			}
			

			play();
		</script>
	</body>
</html>