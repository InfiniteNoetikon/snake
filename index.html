<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Snake Game</title>
		<link rel="icon" type="image/png" href="https://lh6.googleusercontent.com/dY0PlvfHkL-D2M4p7yqePDu4xIvVqdMXerLmDE_IGCR0mc0OO360vZwfi01GCeI9BnbY9zw=w371"></link>
		
		<!-- Basic styling, centering of the canvas. -->
		<style>
			body {
				background: lightgrey;
			}
			h1{
				color: red;
				font-size: 50px;
			}
			
			canvas {
				display: block;
				position: absolute;
				background: black;
				border: 1px solid #000;
				margin: auto;
				top: 0;
				bottom: 0;
				right: 0;
				left: 0;
			}
		</style>
	</head>
	<body>
		<h1 align="center"> Let's Play Snake! </h1>
		<script>
			var
			// Constats
			COLS = 35, ROWS = 35, EMPTY = 3, SNAKE = 1, FRUIT = 2,
			LEFT  = 0, UP = 1, RIGHT = 2, DOWN  = 3,
			KEY_LEFT  = 37, KEY_UP    = 38, KEY_RIGHT = 39, KEY_DOWN  = 40,
			
			// Game objects
			canvas, ctx, keystate, frames, score;

			grid = {
				width: null,  /* number, the number of columns */
				height: null, /* number, the number of rows */
				_grid: null,  /* Array<any>, data representation */
				
				init: function(d, c, r) {
					this.width = c;
					this.height = r;
					this._grid = [];
					for (var x=0; x < c; x++) {
						this._grid.push([]);
						for (var y=0; y < r; y++) {
							this._grid[x].push(d);
						}
					}
				},

				set: function(val, x, y) {
					this._grid[x][y] = val;
				},

				get: function(x, y) {
					return this._grid[x][y];
				}
			}

			snake = {
				direction: null, /* number, the direction */
				last: null,		 /* Object, pointer to the last element in
									the queue */
				_queue: null,	 /* Array<number>, data representation*/

				init: function(d, x, y) {
					this.direction = d;
					this._queue = [];
					this.insert(x, y);
					this.insert(x, y-1);
					this.insert(x,y-2);
				},
				
				insert: function(x, y) {
					// unshift prepends an element to an array
					this._queue.unshift({x:x, y:y});
					this.last = this._queue[0];
				},
				/**
				 * Removes and returns the first element in the queue.
				 * 
				 * @return {Object} the first element
				 */
				remove: function() {
					// pop returns the last element of an array
					return this._queue.pop();
				}
			};
			
			function clickToRestart(){
			
				canvas.onclick = "init()";
			}
			
			function setFood() {
				var empty = [];
				// iterate through the grid and find all empty cells
				for (var x=0; x < grid.width; x++) {
					for (var y=0; y < grid.height; y++) {
						if (grid.get(x, y) === EMPTY) {
							empty.push({x:x, y:y});
						}
					}
				}
				// chooses a random cell
				var randpos = empty[Math.round(Math.random()*(empty.length - 1))];
				grid.set(FRUIT, randpos.x, randpos.y);
			}

			function play() {
				// create and initiate the canvas element
				canvas = document.createElement("canvas");
				canvas.width = COLS*20;
				canvas.height = ROWS*20;
				ctx = canvas.getContext("2d");
				
				// add the canvas element to the body of the document
				document.body.appendChild(canvas);
				
				// sets an base font for bigger score display
				ctx.font = "20px Helvetica";
				frames = 0;
				keystate = {};
				
				// keeps track of the keybourd input
				document.addEventListener("keydown", function(evt) {keystate[evt.keyCode] = true;});
				document.addEventListener("keyup", function(evt) {delete keystate[evt.keyCode];});
				
				// intatiate game objects and starts the game loop
				init();
				loop();
			}

			function init() {
				score = 0;
				grid.init(EMPTY, COLS, ROWS);
				var sp = {x:Math.floor(COLS/2), y:ROWS-1};
				snake.init(UP, sp.x, sp.y);
				grid.set(SNAKE, sp.x, sp.y);
				setFood();
			}

			function loop() {
				update();
				draw();

				window.requestAnimationFrame(loop, canvas);
			}

			function update() {
				frames++;
				
				// changing direction of the snake depending on which keys
				// that are pressed
				if (keystate[KEY_LEFT] && snake.direction !== RIGHT) {
					snake.direction = LEFT;
				}
				if (keystate[KEY_UP] && snake.direction !== DOWN) {
					snake.direction = UP;
				}
				if (keystate[KEY_RIGHT] && snake.direction !== LEFT) {
					snake.direction = RIGHT;
				}
				if (keystate[KEY_DOWN] && snake.direction !== UP) {
					snake.direction = DOWN;
				}
				
				// each five frames update the game state.
				if (frames%5 === 0) {
					// pop the last element from the snake queue i.e. the
					// head
					var nx = snake.last.x;
					var ny = snake.last.y;
					// updates the position depending on the snake direction
					switch (snake.direction) {
						case LEFT:
							nx--;
							break;
						case UP:
							ny--;
							break;
						case RIGHT:
							nx++;
							break;
						case DOWN:
							ny++;
							break;
					}
					if (nx < 0) {
						nx = grid.width-1;
					}
					else if (nx >= grid.width) {
						nx = 0;
					}
					
					if (ny < 0) {
						ny = grid.height-1;
					}
					else if (ny >= grid.height) {
						ny = 0;
					}
				
					// checks gameover condition
					if (grid.get(nx, ny) == SNAKE) {
						return init();
					}
					
					// check wheter the new position are on the fruit item
					if (grid.get(nx, ny) === FRUIT) {
						// increment the score and sets a new fruit position
						score++;
						setFood();
					} 
					else {
						// take out the first item from the snake queue i.e
						// the tail and remove id from grid
						var tail = snake.remove();
						grid.set(EMPTY, tail.x, tail.y);
					}

					grid.set(SNAKE, nx, ny);
					snake.insert(nx, ny);
				}
			}

			function draw() {
				var tw = canvas.width/grid.width;
				var th = canvas.height/grid.height;

				for (var x=0; x < grid.width; x++) {
					for (var y=0; y < grid.height; y++) {

						switch (grid.get(x, y)) {
							case EMPTY:
								ctx.fillStyle = "black";
								ctx.fillRect(x*tw, y*th, tw, th);
								break;
							case SNAKE:
								ctx.fillStyle = "green";
								ctx.fillRect(x*tw, y*th, tw-1, th-1);
								break;
							case FRUIT:
								ctx.fillStyle = "#f00";
								ctx.fillRect(x*tw, y*th, tw-1, th-1);
								break;
						}
					}
				}

				ctx.fillStyle = "White";
				
				ctx.fillText("SCORE: " + score, 10, canvas.height-10);
			}

			play();
		</script>
	</body>
</html>